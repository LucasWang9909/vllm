# 异步RPS控制说明

## 🚀 重要改进：真正的异步RPS控制

之前的版本在RPS控制模式下是**串行等待**的，这意味着每个请求都要等待前一个请求完成才能发送下一个。

### ❌ 旧的串行方式
```
请求1 → 等待完成 → 等待间隔 → 请求2 → 等待完成 → 等待间隔 → 请求3...
```

### ✅ 新的异步方式
```
时间0: 启动请求1
时间1s: 启动请求2 (请求1可能还在进行中)
时间2s: 启动请求3 (请求1,2可能还在进行中)
...
```

## 🔧 实现原理

1. **按间隔调度**：严格按照RPS间隔(1/RPS秒)安排请求启动时间
2. **异步并发**：多个请求可以同时进行，不互相阻塞
3. **准确的RPS**：确保每秒钟启动的请求数量精确符合设定值
4. **实时监控**：
   - 调度进度：显示已启动的请求数
   - 完成进度：显示已完成的请求数和成功率

## 📊 性能对比

### RPS=1，100个请求的情况：

**旧方式（串行）**：
- 如果每个请求耗时2秒，总时间≈200秒
- 实际RPS远低于设定值

**新方式（异步）**：
- 严格按1秒间隔启动，总启动时间=100秒
- 所有请求在约102-105秒内完成（取决于最慢的请求）
- 实际RPS精确为1.0

## 🎯 使用场景

这个改进对以下场景特别有用：

1. **压力测试**：精确控制服务器负载
2. **容量规划**：准确测试特定RPS下的系统表现
3. **长时间基准测试**：避免因串行等待导致的时间浪费
4. **生产环境模拟**：更接近真实的并发访问模式

## 💡 使用示例

```bash
# 1000个请求，严格1 RPS
python benchmark_sharegpt.py --rps 1 --num_prompts 1000
# 预期：1000秒内启动完成，约1010-1020秒内全部完成

# 100个请求，5 RPS
python benchmark_sharegpt.py --rps 5 --num_prompts 100  
# 预期：20秒内启动完成，约22-25秒内全部完成
```

## 📈 监控输出

```
🚀 Starting benchmark with 1000 prompts at 1.0 RPS
   Temperature: 0.7, Max tokens: 150
   Estimated duration: 1000.0 seconds

Scheduled: 50/1000 requests
Scheduled: 100/1000 requests
...
All 1000 requests scheduled. Waiting for completion...
Progress: 50/1000 (5.0%) - Successful: 48
Progress: 100/1000 (10.0%) - Successful: 97
...
✅ All requests completed: 995 total (992 successful)
```

这样您就能获得真正精确的RPS控制，同时保持高效的异步执行！
